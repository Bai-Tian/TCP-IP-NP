# 基于TCP的服务器端/客户端（2）

## TCP原理

### TCP报文头部格式（至少20字节）

     0                   1                   2                   3   
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Source Port(16bits)      |    Destination Port(16bits)   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                   Sequence Number(32bits)                     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                Acknowledgement Number(32bits)                 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Data |           |U|A|P|R|S|F|                               |
    | Offset| Reserved  |R|C|S|S|Y|I|         Window(16bits)        |
    |(4bits)| (6bits)   |G|K|H|T|N|N|                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       Checksum(16bits)        |    Urgent Pointer(16bits)     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    Options                    |    Padding    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                              Data                             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
     Sequence Number: 此TCP报文段的第一个八位字节数据的序列号（存在SYN时除外），若存在SYN,则序列号为初始序列号（ISN），且第一个八位字节数据为ISN+1
     Acknowledgement Number: 如果设置了ACK控制位，则此字段包含TCP报文的发送方希望接收的下一个序列号的值（发送方发送的序列号+1）。一旦建立了连接，就会发送该连接。
     控制位:
     	URG: 紧急
     	ACK: 确认
     	PSH: 传送
     	RST: 重置
     	SYN: 连接
     	FIN: 结束
     
     Data Offset: TCP报文首部的长度
     Reserved: 留至后用
     Window: 控制数据量
     Checksum: 传输数据完整性校验
     Urgent Pointer: 将紧急数据插入到报文数据的最前面

### TCP连接的建立（三报文握手）

    1.客户端发送一个连接请求报文段，报文首部中的SYN控制位置1，并设置一个序列号（Sequence Number）seq = x
    2.服务端返回一个确认报文段，报文首部中的SYN与ACK控制位都置1，并设置一个自己的序列号seq = y，一个确认号（Acknowledgement Number）ack = x + 1
    3.客户端再发送一个确认报文段，报文首部ACK控制位置1，设置确认号ack = y + 1，序列号seq = z（若未携带数据，seq = x + 1）

### TCP连接的结束（四报文挥手）

    1.客户端发送一个连接释放报文段，报文首部中的FIN控制位置1，并设置一个序列号seq = u
    2.服务端返回一个确认报文段，报文首部中的SYN与ACK控制位置1，并设置一个自己的序列号seq = v，确认号ack = u + 1，TCP连接进入半关闭状态（服务端仍可发送数据）
    3.若服务端已再不用发送数据，则服务端发送一个连接释放报文段，报文首部FIN控制位置1，设置序号seq = w，ack = u + 1
    4.客户端再发送一个确认报文段，报文首部ACK控制位置1，设置确认号ack = w + 1 

### TCP套接字中的I/O缓冲

write()函数调用后并非立即传输数据，在write()调用瞬间，数据移至输出缓冲；read()函数调用后也并非马上接收数据，在read()调用瞬间，其从输入缓冲读取数据

I/O缓冲特性：

- I/O缓冲在每个TCP套接字中单独存在
- I/O缓冲在创建套接字时自动生成
- 即使关闭套接字也会继续传递输出缓冲中遗留的数据
- 关闭套接字将丢失输入缓冲中的数据

> TCP协议通过滑动窗口协议，不会因缓冲溢出而丢失数据